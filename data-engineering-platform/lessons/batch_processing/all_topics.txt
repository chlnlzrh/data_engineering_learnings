•	[F]
•	[I]
•	[A]
•	[E]
•	ACID properties (Atomicity, Consistency, Isolation, Durability) [F]
•	Normalization (1NF, 2NF, 3NF, BCNF) [F-I]
•	Primary keys, foreign keys, composite keys [F]
•	Referential integrity and constraints [F]
•	Surrogate keys vs natural keys [I]
•	OLTP vs OLAP systems [F]
•	Row-oriented vs column-oriented storage [I]
•	Transaction isolation levels [A]
•	Numeric data types (INTEGER, DECIMAL, FLOAT, NUMBER) [F]
•	String data types (VARCHAR, CHAR, TEXT) [F]
•	Date and timestamp data types [F]
•	Boolean and binary data types [F]
•	Semi-structured data types (JSON, ARRAY, VARIANT) [I]
•	NULL handling and nullable columns [F]
•	Data type conversions and casting [F-I]
•	Schema definition and DDL concepts [F]
•	Index types and purposes (B-tree, bitmap) [I]
•	Clustered vs non-clustered indexes [I]
•	When to create indexes [I-A]
•	Views vs materialized views [I]
•	Temporary tables vs transient tables [I]
•	Sequences for auto-increment [F]
•	Stored procedures and functions (awareness level) [I]
•	SELECT statements and filtering (WHERE clause) [F]
•	Sorting and limiting results (ORDER BY, LIMIT) [F]
•	Aggregate functions (SUM, COUNT, AVG, MIN, MAX) [F]
•	GROUP BY and HAVING clauses [F]
•	DISTINCT for unique values [F]
•	CASE statements for conditional logic [F-I]
•	NULL handling (IS NULL, COALESCE, NULLIF, NVL, IFNULL) [F-I]
•	INNER JOIN [F]
•	LEFT (OUTER) JOIN [F]
•	RIGHT (OUTER) JOIN [F]
•	FULL (OUTER) JOIN [F-I]
•	CROSS JOIN [I]
•	Self-joins [I]
•	Join conditions and performance implications [I-A]
•	Multiple table joins [I]
•	Subqueries (correlated and non-correlated) [I]
•	Common Table Expressions (CTEs) [I]
•	Recursive CTEs [A]
•	Set operations (UNION, UNION ALL, INTERSECT, EXCEPT) [F-I]
•	Derived tables and inline views [I]
•	EXISTS and NOT EXISTS [I]
•	IN and NOT IN operators [F-I]
•	ANY and ALL operators [I]
•	ROW_NUMBER, RANK, DENSE_RANK, NTILE [I]
•	LAG and LEAD functions [I]
•	FIRST_VALUE and LAST_VALUE [I]
•	Window frames (ROWS BETWEEN, RANGE BETWEEN) [I-A]
•	PARTITION BY clause [I]
•	ORDER BY within window functions [I]
•	Running totals and moving averages [I]
•	Cumulative aggregations [I]
•	PERCENTILE_CONT and PERCENTILE_DISC [I-A]
•	MEDIAN function [I]
•	Statistical functions (STDDEV, VARIANCE, CORR) [I-A]
•	String functions (CONCAT, SUBSTRING, TRIM, SPLIT, REGEXP) [F-I]
•	Date/time functions (DATEADD, DATEDIFF, DATE_TRUNC, EXTRACT) [I]
•	Array functions (ARRAY_AGG, FLATTEN) [I-A]
•	JSON parsing and extraction (PARSE_JSON, JSON_EXTRACT_PATH_TEXT) [I-A]
•	Regular expressions in SQL [I-A]
•	Reading execution plans [I-A]
•	Understanding query cost metrics [I]
•	Filter selectivity and predicate pushdown [I-A]
•	Avoiding SELECT * [F-I]
•	Query optimization fundamentals [I-A]
•	Understanding data scanning metrics [I]
•	ETL vs ELT paradigm differences [F-I]
•	Extract, Load, Transform sequence in ELT [F]
•	Advantages of ELT in cloud data warehouses [I]
•	Staging layer concepts [I]
•	Transformation layer design [I-A]
•	Full refresh vs incremental load strategies [I]
•	Idempotency in data pipelines [I-A]
•	Change Data Capture (CDC) fundamentals [I-A]
•	Data warehouse vs data lake vs lakehouse [I]
•	Multi-tier architecture (staging, integration, presentation) [I]
•	Dimensional vs normalized approaches [I]
•	Conformed dimensions across data marts [I-A]
•	Enterprise data warehouse concepts [I-A]
•	Semantic layers and business logic separation [I-A]
•	Full load (truncate and load) [F-I]
•	Incremental load (append-only) [I]
•	Incremental load (upsert/merge) [I-A]
•	Delta detection methods (timestamp, hash, CDC) [I-A]
•	Batch processing vs streaming [I]
•	Late-arriving facts and dimensions [A]
•	Data refresh strategies and scheduling [I-A]
•	Data quality dimensions (accuracy, completeness, consistency, timeliness, validity, uniqueness) [I]
•	Data profiling techniques [I]
•	Data validation rules [I]
•	Reconciliation methods (row count, sum checks) [I]
•	Error handling strategies [I-A]
•	Data quality monitoring and alerting [I-A]
•	Star schema design [I]
•	Snowflake schema design (vs star schema) [I]
•	Fact tables and measures [I]
•	Dimension tables and attributes [I]
•	Grain definition [I-A]
•	Additive, semi-additive, and non-additive measures [I]
•	Conformed dimensions [I-A]
•	Role-playing dimensions [I-A]
•	Degenerate dimensions [I-A]
•	Junk dimensions [I-A]
•	SCD Type 0 (retain original) [I]
•	SCD Type 1 (overwrite) [I]
•	SCD Type 2 (add new row with history) [I-A]
•	SCD Type 3 (add new column) [I]
•	SCD Type 4 (mini-dimension) [A]
•	SCD Type 6 (hybrid approach) [A]
•	Effective date management (valid_from, valid_to) [I]
•	Current record indicators [I]
•	Surrogate key management in SCD Type 2 [I-A]
•	Factless fact tables [I-A]
•	Accumulating snapshot facts [A]
•	Transaction fact tables [I]
•	Periodic snapshot fact tables [I-A]
•	Bridge tables for many-to-many relationships [I-A]
•	Mini-dimensions for rapidly changing attributes [A]
•	Heterogeneous products handling [A]
•	Multi-valued dimensions [A]
•	Data Vault modeling (Hub, Link, Satellite) - awareness level [A-E]
•	ERD notation and symbols [F]
•	Cardinality (one-to-one, one-to-many, many-to-many) [F]
•	Optionality (mandatory vs optional relationships) [F]
•	Creating and reading ERDs [F-I]
•	Forward and reverse engineering from ERDs [I]
•	Separation of storage and compute [I]
•	Multi-cluster shared data architecture [I-A]
•	Virtual warehouses and compute clusters [I]
•	Cloud services layer [I]
•	Data storage layer (micro-partitions) [I-A]
•	Query processing and optimization layer [I-A]
•	Snowflake editions and features [F-I]
•	Databases, schemas, and tables [F]
•	Account, organization, and hierarchy [I]
•	Stages (internal, external, named) [I]
•	File formats (CSV, JSON, Parquet, Avro, ORC, XML) [I]
•	Sequences for surrogate keys [I]
•	Views and materialized views [I]
•	Secure views [I-A]
•	Streams for CDC [I-A]
•	Tasks for scheduling [I-A]
•	Stored procedures and UDFs (User-Defined Functions) [I-A]
•	External functions [A]
•	Warehouse sizing (X-Small to 6X-Large) [I]
•	Warehouse scaling (scale up vs scale out) [I-A]
•	Multi-cluster warehouses [I-A]
•	Auto-suspend and auto-resume [I]
•	Warehouse modes (Standard vs Economy) [I-A]
•	Query queuing and concurrency [I-A]
•	Resource monitors for cost control [I]
•	COPY INTO command [I]
•	Loading from internal stages [I]
•	Loading from external stages (S3, Azure, GCS) [I]
•	Snowpipe for continuous loading [I-A]
•	Bulk loading best practices [I-A]
•	Data validation during load [I]
•	Error handling and ON_ERROR options [I]
•	COPY INTO transformations [I-A]
•	Time Travel (querying historical data) [I]
•	Zero-copy cloning [I]
•	Data sharing (secure data sharing, data marketplace) [I-A]
•	Fail-safe for disaster recovery [I]
•	Table types (permanent, transient, temporary) [I]
•	Transient vs temporary tables [I]
•	Result caching [I]
•	Metadata caching [I-A]
•	Clustering keys and automatic clustering [I-A]
•	Micro-partitions and pruning [I-A]
•	Search optimization service [A]
•	Materialized views for pre-aggregation [I-A]
•	Query acceleration service [A]
•	Warehouse sizing for workloads [I-A]
•	Query profiling and optimization [I-A]
•	VARIANT data type [I]
•	OBJECT and ARRAY data types [I]
•	Lateral flattening [I-A]
•	Dot notation and bracket notation for JSON [I]
•	Parsing and extracting JSON data [I]
•	Working with nested structures [I-A]
•	Semi-structured data performance considerations [A]
•	Modularity and reusability [I]
•	Separation of concerns (extract, transform, load) [I]
•	Configuration-driven pipelines [I-A]
•	Parameterization of SQL scripts [I]
•	Error handling and retry logic [I-A]
•	Logging and audit trails [I]
•	Pipeline orchestration concepts [I]
•	Dependency management (DAG concepts) [I-A]
•	Staging to integration layer transformations [I]
•	Business logic implementation [I]
•	Lookup and reference data handling [I]
•	Data cleansing and standardization [I]
•	Derived calculations and metrics [I]
•	Aggregation and summarization [I]
•	Data pivoting and unpivoting [I-A]
•	Timestamp-based incremental logic [I]
•	High-water mark tracking [I]
•	Hash-based change detection [I-A]
•	CDC-based incremental patterns [I-A]
•	Merge/upsert logic (MERGE statement) [I-A]
•	Delete detection strategies [I-A]
•	Historical data backfilling [A]
•	Understanding data lineage [I]
•	Tracking data flow through pipelines [I-A]
•	Source-to-target mapping [I]
•	Impact analysis [I-A]
•	Metadata repositories [I-A]
•	Technical vs business metadata [I]
•	Data ownership and stewardship [I]
•	Data policies and standards [I]
•	Master data management concepts [I-A]
•	Reference data management [I]
•	Data lifecycle management [I-A]
•	Data retention policies [I]
•	Data validation rules and checks [I]
•	Schema validation (column existence, data types) [I]
•	Uniqueness checks [I]
•	NOT NULL validation [I]
•	Foreign key relationship validation [I]
•	Business rule validation [I-A]
•	Data quality scoring and metrics [I-A]
•	Data quality dashboards [I-A]
•	Unit testing for transformations [I]
•	Integration testing for pipelines [I-A]
•	Regression testing [I-A]
•	Reconciliation testing (source vs target) [I]
•	Test data management [I-A]
•	Automated testing frameworks (dbt tests, custom SQL tests) [I-A]
•	Data classification (public, internal, confidential, restricted) [I]
•	PII (Personally Identifiable Information) identification [I]
•	Data masking and anonymization [I-A]
•	Encryption at rest and in transit [I]
•	Compliance requirements (GDPR, CCPA awareness) [I-A]
•	Data access audit logging [I]
•	Business glossary and data dictionary [I]
•	Technical metadata (schemas, data types, relationships) [I]
•	Operational metadata (load times, row counts, quality metrics) [I]
•	Data catalog concepts [I-A]
•	Column-level documentation [I]
•	Table-level documentation [I]
•	User management in Snowflake [F-I]
•	Role-Based Access Control (RBAC) [I]
•	Role hierarchy and inheritance [I-A]
•	System-defined roles (ACCOUNTADMIN, SECURITYADMIN, SYSADMIN, PUBLIC) [I]
•	Custom role creation [I]
•	Granting and revoking privileges [I]
•	Future grants [I-A]
•	Principle of least privilege [I]
•	Object-level permissions (databases, schemas, tables, views) [I]
•	Warehouse access control [I]
•	Column-level security [I-A]
•	Row-level security (secure views, row access policies) [I-A]
•	Dynamic data masking policies [A]
•	Tag-based masking policies [A]
•	Network policies and IP whitelisting [I]
•	Multi-factor authentication (MFA) [I]
•	Single Sign-On (SSO) integration [I-A]
•	Key pair authentication [I-A]
•	OAuth integration [A]
•	Service accounts vs user accounts [I]
•	Search-driven analytics concepts [I]
•	Natural language search [I]
•	SpotIQ for automated insights [I-A]
•	Data connections to Snowflake [I]
•	Live query vs in-memory analytics [I]
•	Worksheets and views [I]
•	Answer creation and saving [I]
•	Pinboards (dashboards) creation [I]
•	Logical table and column configuration [I]
•	Relationships and joins in ThoughtSpot [I]
•	Calendar tables and date dimensions [I]
•	Aggregation and formula configuration [I-A]
•	Search customization (synonyms, indexing) [I-A]
•	Column properties and formatting [I]
•	Security at worksheet level [I-A]
•	Chart types and when to use them (bar, line, pie, scatter, heatmap, etc.) [I]
•	Key Performance Indicators (KPIs) and scorecards [I]
•	Dashboard layout and design principles [I]
•	Filters and parameters [I]
•	Interactive dashboards (drill-down, cross-filtering) [I]
•	Mobile-responsive design [I-A]
•	Accessibility considerations (color-blind friendly palettes) [I]
•	Power BI architecture and data model [I]
•	Tableau workbooks and data sources [I]
•	Looker and LookML [I-A]
•	Qlik Sense associative model [I]
•	Mode Analytics SQL-based reporting [I]
•	Business-friendly naming conventions [I]
•	Metric definitions and calculations [I]
•	Calculated fields and measures [I]
•	Dimension hierarchies [I]
•	Aggregation rules [I-A]
•	Centralized business logic [I-A]
•	Pre-aggregated tables and views [I-A]
•	Incremental refresh strategies [I-A]
•	Caching mechanisms [I]
•	Query optimization for BI tools [I-A]
•	Materialized views for reporting [I-A]
•	Dashboard performance best practices [I-A]
•	File system navigation (cd, ls, pwd) [F]
•	File operations (cp, mv, rm, mkdir, rmdir) [F]
•	File permissions (chmod, chown) [F-I]
•	Viewing file contents (cat, less, more, head, tail) [F]
•	Text editing (vi/vim basics or nano) [F-I]
•	File searching (find, grep) [F-I]
•	Environment variables and PATH [I]
•	Bash scripting basics [I]
•	Variables and parameter passing [I]
•	Conditionals (if-else) [I]
•	Loops (for, while) [I]
•	Functions in shell scripts [I]
•	Exit codes and error handling [I]
•	Script scheduling and automation [I-A]
•	Text processing (awk, sed) [I-A]
•	File compression (gzip, tar) [I]
•	CSV file handling [I]
•	Large file processing techniques [I-A]
•	File transfer (scp, sftp) [I]
•	File watching and monitoring [I-A]
•	Reading and analyzing log files [I]
•	Log rotation concepts [I]
•	Grep patterns for log analysis [I]
•	Debugging shell scripts [I-A]
•	System resource monitoring (top, df, du) [I]
•	Repository concepts (local vs remote) [F]
•	Git initialization and cloning (git init, git clone) [F]
•	Basic workflow (git add, git commit, git push, git pull) [F]
•	Checking status and history (git status, git log, git diff) [F]
•	.gitignore patterns [F-I]
•	Creating and switching branches (git branch, git checkout, git switch) [I]
•	Feature branch workflow [I]
•	Merging branches (git merge) [I]
•	Rebasing (git rebase) [I-A]
•	Resolving merge conflicts [I]
•	Branch naming conventions [F-I]
•	Pull requests / merge requests [I]
•	Code review process and etiquette [I]
•	Forking and contributing [I]
•	Remote repository management (git remote) [I]
•	Fetching vs pulling (git fetch, git pull) [I]
•	Stashing changes (git stash) [I]
•	Commit message conventions [I]
•	Atomic commits [I]
•	When to commit and push [I]
•	Avoiding sensitive data in repositories [I]
•	Using branches for environment separation (dev, staging, prod) [I]
•	Understanding query execution plans [I-A]
•	Identifying performance bottlenecks [I-A]
•	Query profiling in Snowflake [I-A]
•	Analyzing bytes scanned and pruning efficiency [I-A]
•	Warehouse utilization metrics [I-A]
•	Query history analysis [I]
•	Clustering key selection and optimization [A]
•	Partition pruning strategies [I-A]
•	Micro-partition statistics [A]
•	Reducing data scanning through filters [I-A]
•	Materialized view usage [I-A]
•	Result set caching strategies [I-A]
•	Query acceleration service [A]
•	Filter pushdown and early filtering [I]
•	Join order optimization [I-A]
•	Avoiding Cartesian products [I]
•	Using appropriate join types [I]
•	Minimizing subquery usage [I-A]
•	CTE vs subquery performance [I-A]
•	DISTINCT optimization [I-A]
•	Aggregate function optimization [I-A]
•	Parallel processing and concurrency [I-A]
•	Batch sizing optimization [I-A]
•	Staging vs direct transformations [I-A]
•	Avoiding row-by-row processing [I]
•	Set-based operations [I]
•	Incremental vs full refresh decisions [I-A]
•	Reading error messages and stack traces [I]
•	Debugging SQL queries step-by-step [I]
•	Isolating problematic sections [I]
•	Testing with sample data [I]
•	Data reconciliation methods [I]
•	Root cause analysis for data issues [I-A]
•	Snowflake query profiler interpretation [I-A]
•	Warehouse sizing and auto-suspend tuning [I-A]
•	Storage cost management [I-A]
•	Query cost monitoring [I-A]
•	Credit consumption tracking [I]
•	Resource monitors and alerts [I]
•	Table type selection (permanent vs transient) [I]
•	Time Travel retention policies [I-A]
•	Development, staging, and production environments [I]
•	Environment-specific configurations [I]
•	Schema separation strategies [I-A]
•	Promoting code across environments [I]
•	Blue-green deployment concepts [A]
•	SQL script versioning [I]
•	Database migration tools (Flyway, Liquibase awareness) [I-A]
•	Automated deployment pipelines [I-A]
•	Rollback strategies [I-A]
•	Schema change management [I-A]
•	Automated SQL testing [I-A]
•	Pre-commit hooks [I]
•	SQL linting and formatting [I]
•	Integration testing in pipelines [I-A]
•	Test data management [I-A]
•	Data freshness monitoring [I]
•	Pipeline execution status tracking [I]
•	Failure detection and alerting [I]
•	Execution duration tracking [I]
•	Data volume anomaly detection [I-A]
•	Automated quality checks [I]
•	Quality metric dashboards [I]
•	Trend analysis for quality metrics [I-A]
•	Alert configuration for quality issues [I]
•	Test result tracking over time [I]
•	Account usage views [I]
•	Query history analysis [I]
•	Warehouse performance monitoring [I]
•	Storage usage monitoring [I]
•	Credit consumption tracking [I]
•	Login history and security monitoring [I]
•	DAG (Directed Acyclic Graph) design [I-A]
•	Task dependencies and precedence [I]
•	Parallel vs sequential execution [I]
•	Error handling and retry mechanisms [I-A]
•	SLA monitoring and alerting [I-A]
•	Apache Airflow (DAGs, operators, sensors) [I-A]
•	dbt for SQL-based transformations [I]
•	Snowflake Tasks and Streams [I-A]
•	Apache NiFi [A]
•	AWS Step Functions / Azure Data Factory [I-A]
•	Cron expressions [I]
•	Time zone considerations [I]
•	Execution windows and maintenance windows [I]
•	Backfilling historical data [I-A]
•	Handling late-arriving data [A]
•	Models as SELECT statements [I]
•	Project structure (models, macros, tests, seeds) [I]
•	Materializations (view, table, incremental, ephemeral) [I]
•	refs() and sources() for lineage [I]
•	Jinja templating in SQL [I-A]
•	Schema tests (unique, not_null, relationships, accepted_values) [I]
•	Custom data tests [I]
•	schema.yml configuration [I]
•	Auto-generated documentation [I]
•	Lineage graphs [I]
•	Incremental models [I-A]
•	Snapshots for SCD Type 2 [I-A]
•	Macros for reusable logic [I-A]
•	Packages (dbt_utils) [I]
•	Custom materializations [A-E]
•	Translating technical concepts for non-technical stakeholders [I]
•	Writing clear documentation [I]
•	Effective email and chat communication [I]
•	Presenting technical solutions [I]
•	Active listening and asking clarifying questions [I]
•	Inline SQL code comments [I]
•	README files for repositories [I]
•	Data dictionary creation [I]
•	Technical design documents [I-A]
•	Runbooks for operational procedures [I]
•	Process documentation [I]
•	Code review participation (giving and receiving feedback) [I]
•	Pair programming [I]
•	Knowledge sharing and mentoring [I-A]
•	Cross-functional collaboration with business users [I]
•	Agile/Scrum ceremonies (standups, retrospectives) [I]
•	Breaking down complex problems [I]
•	Root cause analysis (5 Whys technique) [I]
•	Debugging methodology [I]
•	Asking for help effectively [I]
•	Learning from mistakes [I]
•	Managing multiple tasks and priorities [I]
•	Estimating effort and timelines [I-A]
•	Meeting deadlines [I]
•	Balancing technical debt vs feature delivery [I-A]
•	Staying current with industry trends [I]
•	Learning new technologies independently [I]
•	Building a professional network [I]
•	Seeking and incorporating feedback [I]
•	Career goal setting [I]
•	Revenue, profit, margin [F-I]
•	Customer metrics (CAC, LTV, churn, retention) [I]
•	Growth metrics (MoM, YoY, CAGR) [I]
•	Operational metrics (efficiency, productivity) [I]
•	Cohort analysis concepts [I-A]
•	Business requirements gathering [I]
•	Translating business questions to SQL [I]
•	Understanding data consumers and use cases [I]
•	Identifying key stakeholders [I]
•	Business process understanding [I]
•	Domain-specific terminology [I]
•	Regulatory and compliance requirements [I-A]
•	Industry-standard KPIs [I]
•	Reporting calendars (fiscal vs calendar year) [I]
•	JSON structure and syntax [F-I]
•	Parsing JSON in SQL [I]
•	Flattening nested structures [I-A]
•	Working with arrays in JSON [I-A]
•	Performance considerations for semi-structured data [A]
•	CSV format and delimiters [F]
•	JSON and JSONL (newline-delimited JSON) [I]
•	Parquet columnar format [I]
•	Avro format [I]
•	ORC format [I]
•	XML basics [I]
•	API concepts (endpoints, methods, authentication) [I]
•	HTTP methods (GET, POST, PUT, DELETE) [F-I]
•	API authentication (API keys, OAuth) [I]
•	Reading API documentation [I]
•	Rate limiting and pagination [I-A]
•	Basic Python syntax [F-I]
•	Data structures (lists, dictionaries, sets) [F-I]
•	Pandas for data manipulation [I]
•	Requests library for API calls [I]
•	File I/O operations [I]
•	Error handling in Python [I]
•	Data mesh principles (awareness level) [A-E]
•	Domain-oriented decentralized data ownership [A-E]
•	Data products concept [A-E]
•	Self-serve data infrastructure [A-E]
•	DataOps principles and culture [I-A]
•	Continuous integration for data pipelines [I-A]
•	Automated testing and validation [I-A]
•	Monitoring and observability [I-A]
•	Incident response for data issues [I-A]
•	Batch vs streaming concepts [I]
•	Kafka and event streaming basics [I-A]
•	Change Data Capture (CDC) mechanisms [I-A]
•	Snowflake Streams for CDC [I-A]
•	Micro-batch processing [A]
•	AWS, Azure, or GCP fundamentals [I]
•	Cloud storage services (S3, Azure Blob, GCS) [I]
•	IAM and access management [I]
•	Cloud cost management [I-A]
•	Multi-cloud awareness [A]
•	Machine learning pipeline concepts [I-A]
•	Feature engineering for ML [I-A]
•	Snowflake integration with ML platforms [A]
•	Model scoring and prediction in SQL [A]
